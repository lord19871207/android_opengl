#version 300 es

uniform sampler2D sTexture;
uniform vec2 uSampleOffset;

in vec2 vTexPosition;

out vec4 outFragColor;

void main() {
    const int radius = 5;
    const int radius2 = (radius + 1) * (radius + 1);
    const float n = float((radius + 1) * (radius + 1));

    vec3 m[4];
    vec3 s[4];
    m[0] = vec3(0.0); m[1] = vec3(0.0); m[2] = vec3(0.0); m[3] = vec3(0.0);
    s[0] = vec3(0.0); s[1] = vec3(0.0); s[2] = vec3(0.0); s[3] = vec3(0.0);

    for (int k = 0; k < radius2; ++k)  {
        int i = k / (radius + 1);
        int j = k - i * (radius + 1);
        vec3 c0 = texture(sTexture, vTexPosition + vec2(i, j) * uSampleOffset).rgb;
        vec3 c1 = texture(sTexture, vTexPosition + vec2(i + radius, j) * uSampleOffset).rgb;
        vec3 c2 = texture(sTexture, vTexPosition + vec2(i, j + radius) * uSampleOffset).rgb;
        vec3 c3 = texture(sTexture, vTexPosition + vec2(i + radius, j + radius) * uSampleOffset).rgb;
        m[0] += c0; s[0] += c0 * c0;
        m[1] += c1; s[1] += c1 * c1;
        m[2] += c2; s[2] += c2 * c2;
        m[3] += c3; s[3] += c3 * c3;
    }

    float min_sigma2 = 1e+2;
    for (int k = 0; k < 4; ++k) {
        m[k] /= n;
        s[k] = abs(s[k] / n - m[k] * m[k]);
        float sigma2 = s[k].r + s[k].g + s[k].b;
        if (sigma2 < min_sigma2) {
            min_sigma2 = sigma2;
            outFragColor = vec4(m[k], 1.0);
        }
    }
}
